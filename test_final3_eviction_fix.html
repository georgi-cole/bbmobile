<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Test Final 3 Eviction Fix - Big Brother</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
      padding: 20px;
      background: #0a0e1a;
      color: #eaf4ff;
      line-height: 1.6;
    }
    .container {
      max-width: 900px;
      margin: 0 auto;
      background: #0e1622;
      padding: 30px;
      border-radius: 12px;
      border: 1px solid rgba(110,160,220,.18);
    }
    h1 {
      color: #ffdc8b;
      margin-top: 0;
    }
    .test-section {
      margin: 25px 0;
      padding: 20px;
      background: rgba(20, 30, 50, 0.5);
      border-radius: 8px;
      border-left: 3px solid #4a90e2;
    }
    .test-section h2 {
      margin-top: 0;
      color: #4a90e2;
      font-size: 1.3em;
    }
    .test-result {
      margin: 10px 0;
      padding: 10px;
      border-radius: 5px;
      font-family: 'Courier New', monospace;
    }
    .pass {
      background: rgba(46, 204, 113, 0.2);
      border-left: 3px solid #2ecc71;
    }
    .fail {
      background: rgba(231, 76, 60, 0.2);
      border-left: 3px solid #e74c3c;
    }
    .info {
      background: rgba(52, 152, 219, 0.2);
      border-left: 3px solid #3498db;
    }
    button {
      padding: 12px 24px;
      margin: 10px 5px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      transition: all 0.2s;
    }
    .btn-primary {
      background: #4a90e2;
      color: white;
    }
    .btn-primary:hover {
      background: #357abd;
    }
    code {
      background: rgba(255, 255, 255, 0.1);
      padding: 2px 6px;
      border-radius: 3px;
      font-family: 'Courier New', monospace;
    }
    .status {
      display: inline-block;
      padding: 4px 10px;
      border-radius: 4px;
      font-weight: 600;
      margin-left: 10px;
    }
    .status.pass { background: #2ecc71; color: white; }
    .status.fail { background: #e74c3c; color: white; }
  </style>
</head>
<body>
  <div class="container">
    <h1>üèÜ Final 3 Eviction Fix Test Suite</h1>
    
    <div class="test-section">
      <h2>Purpose</h2>
      <p>This test validates the fixes for Final 3 eviction bugs:</p>
      <ul>
        <li>‚úÖ Only a single eviction event occurs (no duplicates)</li>
        <li>‚úÖ Guard flags prevent repeated evictions</li>
        <li>‚úÖ Badges are cleared after eviction</li>
        <li>‚úÖ Only 2 players remain for jury vote</li>
        <li>‚úÖ No dummy houseguests created for jury</li>
        <li>‚úÖ postEvictionRouting properly handles 2-player flow</li>
      </ul>
    </div>

    <div class="test-section">
      <h2>Test Controls</h2>
      <button class="btn-primary" onclick="runAllTests()">Run All Tests</button>
    </div>

    <div id="results"></div>
  </div>

  <script>
    const results = [];

    function log(message, type = 'info') {
      const result = { message, type, timestamp: Date.now() };
      results.push(result);
      
      const resultsDiv = document.getElementById('results');
      const div = document.createElement('div');
      div.className = `test-result ${type}`;
      div.textContent = message;
      resultsDiv.appendChild(div);
    }

    function testGuardFlags() {
      log('Testing guard flags...', 'info');
      
      // Mock game object
      const mockGame = {
        __f3EvictionResolved: false,
        __f3EvictionInProgress: false,
        players: [
          { id: 0, name: 'Alice', evicted: false, affinity: {} },
          { id: 1, name: 'Bob', evicted: false, affinity: {} },
          { id: 2, name: 'Carol', evicted: false, affinity: {} }
        ],
        hohId: 0,
        nominees: [1, 2],
        juryHouse: [],
        cfg: { enableJuryHouse: true },
        week: 10
      };

      // Test 1: Guard flags should prevent duplicate calls
      const evictionCount = { count: 0 };
      
      function mockFinalize(game, evictId) {
        if (game.__f3EvictionResolved) {
          log('‚úÖ PASS: Guard flag prevented duplicate eviction', 'pass');
          return false;
        }
        if (game.__f3EvictionInProgress) {
          log('‚úÖ PASS: In-progress flag prevented concurrent eviction', 'pass');
          return false;
        }
        
        game.__f3EvictionInProgress = true;
        game.__f3EvictionResolved = true;
        evictionCount.count++;
        
        // Mark player as evicted
        const evictee = game.players.find(p => p.id === evictId);
        if (evictee) {
          evictee.evicted = true;
        }
        
        return true;
      }

      // First call should succeed
      if (mockFinalize(mockGame, 1)) {
        log('‚úÖ PASS: First eviction call succeeded', 'pass');
      } else {
        log('‚ùå FAIL: First eviction call failed', 'fail');
      }

      // Second call should be prevented
      if (!mockFinalize(mockGame, 2)) {
        log('‚úÖ PASS: Second eviction call blocked by guard flag', 'pass');
      } else {
        log('‚ùå FAIL: Second eviction call was not blocked', 'fail');
      }

      // Verify only one eviction occurred
      if (evictionCount.count === 1) {
        log('‚úÖ PASS: Only one eviction occurred', 'pass');
      } else {
        log(`‚ùå FAIL: Expected 1 eviction, got ${evictionCount.count}`, 'fail');
      }
    }

    function testBadgeClearing() {
      log('Testing badge clearing...', 'info');
      
      const mockGame = {
        players: [
          { id: 0, name: 'Alice', evicted: false, nominated: false, hoh: true, affinity: {} },
          { id: 1, name: 'Bob', evicted: false, nominated: true, hoh: false, affinity: {} },
          { id: 2, name: 'Carol', evicted: false, nominated: true, hoh: false, affinity: {} }
        ],
        hohId: 0,
        nominees: [1, 2],
        vetoHolder: 0,
        nomsLocked: true,
        juryHouse: [],
        cfg: { enableJuryHouse: true }
      };

      // Simulate badge clearing after eviction
      function clearBadges(game) {
        game.nominees = [];
        game.vetoHolder = null;
        game.nomsLocked = false;
        game.players.forEach(p => {
          p.nominated = false;
          p.hoh = false;
        });
        game.hohId = null;
      }

      clearBadges(mockGame);

      // Verify badges are cleared
      if (mockGame.nominees.length === 0) {
        log('‚úÖ PASS: Nominees cleared', 'pass');
      } else {
        log('‚ùå FAIL: Nominees not cleared', 'fail');
      }

      if (mockGame.vetoHolder === null) {
        log('‚úÖ PASS: Veto holder cleared', 'pass');
      } else {
        log('‚ùå FAIL: Veto holder not cleared', 'fail');
      }

      if (mockGame.hohId === null) {
        log('‚úÖ PASS: HOH cleared', 'pass');
      } else {
        log('‚ùå FAIL: HOH not cleared', 'fail');
      }

      const anyHoh = mockGame.players.some(p => p.hoh);
      const anyNom = mockGame.players.some(p => p.nominated);

      if (!anyHoh) {
        log('‚úÖ PASS: All player HOH badges cleared', 'pass');
      } else {
        log('‚ùå FAIL: Some players still have HOH badge', 'fail');
      }

      if (!anyNom) {
        log('‚úÖ PASS: All player nomination badges cleared', 'pass');
      } else {
        log('‚ùå FAIL: Some players still nominated', 'fail');
      }
    }

    function testPlayerCount() {
      log('Testing player count after eviction...', 'info');
      
      const mockGame = {
        players: [
          { id: 0, name: 'Alice', evicted: false },
          { id: 1, name: 'Bob', evicted: true },
          { id: 2, name: 'Carol', evicted: false }
        ]
      };

      function alivePlayers(game) {
        return game.players.filter(p => !p.evicted);
      }

      const alive = alivePlayers(mockGame);
      
      if (alive.length === 2) {
        log('‚úÖ PASS: Exactly 2 players remain after Final 3 eviction', 'pass');
      } else {
        log(`‚ùå FAIL: Expected 2 alive players, got ${alive.length}`, 'fail');
      }
    }

    function testPostEvictionRouting() {
      log('Testing postEvictionRouting flow...', 'info');
      
      const mockGame = {
        players: [
          { id: 0, name: 'Alice', evicted: false },
          { id: 1, name: 'Bob', evicted: false }
        ]
      };

      function alivePlayers(game) {
        return game.players.filter(p => !p.evicted);
      }

      function mockPostEvictionRouting(game) {
        const remain = alivePlayers(game);
        
        if (remain.length === 2) {
          log('‚úÖ PASS: postEvictionRouting detected 2 players', 'pass');
          log('‚úÖ PASS: Would call startJuryVote()', 'pass');
          return 'jury_vote';
        }
        
        if (remain.length === 3) {
          log('‚úÖ PASS: Would call startFinal3Flow()', 'pass');
          return 'final3_flow';
        }
        
        log('‚úÖ PASS: Would proceed to next week', 'pass');
        return 'next_week';
      }

      const result = mockPostEvictionRouting(mockGame);
      
      if (result === 'jury_vote') {
        log('‚úÖ PASS: Routing correctly handles 2-player scenario', 'pass');
      } else {
        log('‚ùå FAIL: Incorrect routing for 2-player scenario', 'fail');
      }
    }

    function testNoFakeJurors() {
      log('Testing jury composition (no dummy houseguests)...', 'info');
      
      const mockGame = {
        players: [
          { id: 0, name: 'Alice', evicted: false, weekEvicted: null },
          { id: 1, name: 'Bob', evicted: true, weekEvicted: 8 },
          { id: 2, name: 'Carol', evicted: true, weekEvicted: 9 },
          { id: 3, name: 'Dave', evicted: true, weekEvicted: 10 },
          { id: 4, name: 'Eve', evicted: true, weekEvicted: 11 }
        ],
        juryHouse: [1, 2, 3, 4]
      };

      // Test ensureOddJurors logic
      function ensureOddJurors(list, players) {
        if (!list || list.length === 0) return list;
        if (list.length % 2 === 1) return list; // already odd
        
        // Find earliest-evicted juror to drop
        let earliestIdx = 0;
        let earliestWeek = Infinity;
        list.forEach((id, idx) => {
          const p = players.find(pl => pl.id === id);
          const wk = p ? p.weekEvicted : null;
          if (wk != null && wk < earliestWeek) {
            earliestWeek = wk;
            earliestIdx = idx;
          }
        });
        
        const filtered = list.filter((_, i) => i !== earliestIdx);
        return filtered;
      }

      const jurors = ensureOddJurors(mockGame.juryHouse, mockGame.players);
      
      if (jurors.length === 3) {
        log('‚úÖ PASS: Odd jury count maintained (3 jurors)', 'pass');
      } else {
        log(`‚ùå FAIL: Expected odd jury count, got ${jurors.length}`, 'fail');
      }

      // Verify all jurors are real players
      const allReal = jurors.every(id => mockGame.players.some(p => p.id === id && p.evicted));
      
      if (allReal) {
        log('‚úÖ PASS: All jurors are real evicted players (no dummies)', 'pass');
      } else {
        log('‚ùå FAIL: Some jurors are not real players', 'fail');
      }

      // Verify earliest evicted was dropped
      if (!jurors.includes(1)) {
        log('‚úÖ PASS: Earliest-evicted juror correctly dropped', 'pass');
      } else {
        log('‚ùå FAIL: Earliest-evicted juror was not dropped', 'fail');
      }
    }

    function testExportedFunction() {
      log('Testing postEvictionRouting export...', 'info');
      
      // Check if postEvictionRouting is exported to global scope
      if (typeof window.postEvictionRouting !== 'undefined') {
        log('‚úÖ PASS: postEvictionRouting is exported', 'pass');
      } else {
        log('‚ö†Ô∏è  INFO: postEvictionRouting not yet loaded (expected in standalone test)', 'info');
      }
    }

    function runAllTests() {
      // Clear previous results
      document.getElementById('results').innerHTML = '';
      results.length = 0;
      
      log('=== Starting Final 3 Eviction Fix Test Suite ===', 'info');
      
      testGuardFlags();
      testBadgeClearing();
      testPlayerCount();
      testPostEvictionRouting();
      testNoFakeJurors();
      testExportedFunction();
      
      // Summary
      const passCount = results.filter(r => r.type === 'pass').length;
      const failCount = results.filter(r => r.type === 'fail').length;
      
      log('', 'info');
      log('=== Test Summary ===', 'info');
      log(`‚úÖ Passed: ${passCount}`, 'pass');
      if (failCount > 0) {
        log(`‚ùå Failed: ${failCount}`, 'fail');
      } else {
        log('üéâ All tests passed!', 'pass');
      }
    }

    // Auto-run tests on load
    window.addEventListener('DOMContentLoaded', () => {
      setTimeout(runAllTests, 100);
    });
  </script>
</body>
</html>
